# Filter

- 访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能如：登录验证、统一编码处理、敏感字符过滤等

- 步骤

  1. 定义一个类，实现接口Filter
  2. 复写方法：在`doFilter()`中要放行：`chain.doFilter(request, response);`
  3. 配置拦截路径：web.xml或注解：`@WebFilter("/*")`

- web.xml配置

  ```xml
  <filter>
      <filter-name>demo1</filter-name>
      <filter-class>web.filter.FilterDemo1</filter-class>
  </filter>
  
  <filter-mapping>
      <filter-name>demo1</filter-name>
      <url-pattern>/*</url-pattern>
  </filter-mapping>
  ```

- 执行流程：执行过滤器-->执行放行后的资源-->执行过滤器放行代码后的代码

- 生命周期

  - `init()`：在服务器启动后会创建Filter对象调用，只执行一次，用于加载资源
  -  `doFilter()`：每一次请求被拦截资源时执行，执行多次
  - `destroy()`：服务器关闭后Filter对象被销毁，如果正常关闭则会执行，只执行一次，用于释放资源

- 配置详解

  - 拦截路径配置
    1. 具体资源路径：/index.jsp
    2. 拦截目录：/user/*
    3. 后缀名拦截：*.jsp
    4. 拦截所有资源：/*
  - 拦截方式配置：资源被访问的方式
    - 注解配置
      - 设置dispatcherTypes属性
        1. REQUEST：默认值，浏览器直接请求资源
        2. FORWARD：转发访问资源
        3. INCLUDE：包含访问资源
        4. ERROR：错误跳转资源
        5. ASYNC：异步访问资源
      - web.xml配置：设置\<dispatcher>\</dispatcher>标签即可

- 过滤器链：1-->2-->资源执行-->2-->1

  - 先后顺序问题
    1. 注解配置：按照类名的字符串比较规则比较，值小的先执行
    2. web.xml配置： \<filter-mapping>谁定义在上边，谁先执行

## 代理模式

- 代理对象代理真实对象，达到增强真实对象功能的目的
- 静态代理：有一个类文件描述代理模式
- 动态代理：在内存中形成代理类
  1. 代理对象和真实对象实现相同的接口
  2. 代理对象 = `Proxy.newProxyInstance(真实对象.getClass().getClassLoader(), 真实对象.getClass().getInterfaces(), new InvocationHandler(){})`;
  3. 使用代理对象调用方法
  4. 增强方法
- 增强方式：增强参数列表，增强返回值类型，增强方法体执行逻辑

# Listener

- 事件监听机制
  - 事件
  - 事件源：事情发生的地方
  - 监听器：一个对象
  - 注册监听：将事件、事件源、监听器绑定在一起，当事件源上发生某个事件后，执行监听器代码

- `ServletContextListener`:监听`ServletContext`对象的创建和销毁

  - `void contextDestroyed(ServletContextEvent sce)`：`ServletContext`对象被销毁之前会调用该方法
  - `void contextInitialized(ServletContextEvent sce)` ：`ServletContext`对象创建后会调用该方法

- 步骤

  1. 定义一个类，实现`ServletContextListener`接口

  2. 复写方法

  3. 配置

     1.  web.xml

        ```xml
        <listener>
         	<listener-class>cn.itcast.web.listener.ContextLoaderListener</listener-class>
        </listener>
        ```

        指定初始化参数\<context-param>

     2. 注解：`@WebListener`